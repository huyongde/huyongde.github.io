---
layout: post
title: 进程，线程，协程 学习比较
tags: thread coroutine
---

###参考
* [廖雪峰协程介绍](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000)
* [UC 技术博客-协程实现基础](http://tech.uc.cn/?p=1055)
* [进程线程协程和goroutine那些事](http://www.cnblogs.com/shenguanpu/archive/2013/05/05/3060616.html)
* [sf上七牛云介绍python中进程线程协程相关技术](https://segmentfault.com/a/1190000001813992#articleHeader28)
* [赖勇浩 协程介绍](http://blog.csdn.net/gzlaiyonghao/article/details/5397038)

###相关知识汇总
```
协程可以认为是一种**用户态轻量级的线程**，操作系统是感知不到协程的存在的。
与系统提供的线程不同点是， 它需要主动让出CPU时间，而不是由系统进行调度，
即控制权在程序员手上,只需要进行用户态上下文切换。

既然看成是用户态线程，那必然要求程序员自己进行各个协程的调度，
这样就必须提供一种机制,供编写协程的人将当前协程挂起，即保存协程运行场景的一些数据，
调度器在其他协程挂起时再将此协程运行场景的数据恢复，以便继续运行。
这里我们将协程运行场景的数据称为上下文。

在linux里，有getcontext和swapcontext等接口来获取当前的上下文数据和切换上下文。
那如果没有提供相应的接口，又该如何来实现呢？

其实说到底，保存下上文数据，不外乎就是保存下当前运行的栈空间的数据，
还有cpu各个寄存器相应的值。只要我们能够将其保存下来，在特定的时刻恢复回去就可以了。
```

###线程和协程的区别：

> 一旦创建完线程，你就无法决定他什么时候获得时间片，什么时候让出时间片了，你把它交给了内核。
> 而协程编写者可以有一是可控的切换时机，二是很小的切换代价。
> 从操作系统有没有调度权上看，协程就是因为不需要进行内核态的切换，所以会使用它，
> 赖勇浩和dccmx 这个定义我觉得相对准确  **协程是用户态的轻量级的线程**。


